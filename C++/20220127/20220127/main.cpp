#include "Arr.h"
#include <time.h>
#include <random>

// C++ 클래스의 3가지 특징
// 접근제한 지정자
// 생성자, 소멸자
// 멤버함수

class CMy
{
	// C에는 없지만 C++에는
	// 접근 제한 지정자가 생겼어
	// private, protected, public

	// 구조체는 멤버안의 객체를 마음대로 수정 가능
	// 의도치않게 값을 수정해버릴수도 있음

private:
	int m_i1; // 얘는 메인에서 접근 불가능함 여기 클래스에서만 접근 가능
	float m_f;
public:
	int m_i2; // 얘는 메인에서 접근 가능

	// 멤버함수(전용함수)
	// 해당 클래스의 객체가 반드시 필요함
	// 멤버함수를 객체를 통해서 호출하면, 해당 객체의 주소가 this라는 이름의 포인터로 전달

public:
	void SetInt(int i)
	{
		m_i1 = i;
		// this->m_i1 = i 사실은 이런 코드고 this는 생략되어있음
		// 실제로 디버그 해보면 객체의 주소를 받아오는 this라는 이름이 있음
		
	}
	/*
	c언어에서는 우리가 구조체 사용할때처럼 누구의 객체에서 사용할지 멤버로 받아줘야했음
	void SetInt(CMy _this, int i)
	{
		m_i1 = i;
	}
	*/

	// 대입 연산자
	// 얘도 생성자 소멸자처럼 내가 만들어주지 않았지만 자동으로 만들어짐
	CMy& operator =(const CMy& _Other)
	// operator = : 해당 클래스쪽에 대입 연산자(=)가 발생했을때 호출되는 함수다 라는 뜻
	// 인자 (const CMy& _Other)는 _Other의 주소를 참조하는데 const로 참조하니까
	// 이 함수 내에서 해당 주소 및 주소의 내부도 변경 불가능하게 하겠다 라는 뜻
	{
		m_i1 = _Other.m_i1;
		m_i2 = _Other.m_i2;
		m_f = _Other.m_f;

		return *this; // *this 즉 this의 내부값(원본)을 참조형으로 주겠다는 뜻
	}
	

		// 자료형* 변수명			: 자료형의 포인터 타입
		// *포인터변수			: 포인터변수에 저장된 주소에 역참조
		// &변수					: 변수 주소값 반환
		// 자료형& 변수명			: 레퍼런스 변수 선언


	// 우리가 배열이나 리스트 구조체 init이랑 release 함수 만들어줬듯이
	// 클래스에서는 생성자라고 클래스가 객체가 만들어지면 자동으로 실행되는 친구가 있음
	// 근데 이것은 진정한 의미의 초기화가 아님
	// 어셈블리 동작을 확인해 보면 객체가 만들어지고 나서 생성자가 call 되는것
	// 진정한 초기화는 객체가 만들어지는 동시에 초기화가 되는것
public:
	// 생성자 (반환타입 없음)
	CMy()
		: m_i1(100) // 이렇게하면 객체가 만들어지는 순간 초기화가 된다.
		, m_f(0.f)
	{
		// m_i1 = 100 위에서 언급한 가짜 의미의 초기화
	}

	// 소멸자 - 구조체 사용했을때 만들었던 release와 비슷한 성격
	// 객체가 없어질때 자동으로 호출
	~CMy()
	{

	}

	// 생성자랑 소멸자를 이렇게 우리가 안만들어줘도
	// C++ 문법상 생성자와 소멸자는 필수적이기 때문에
	// 컴파일러 내에서 디폴트 생/소멸자를 자동으로 만들어줌 (아무 기능도 없음)
	// 그냥 호출해야되는데 뭐가 있어야되니까 형식상 있는거 맞음

};



int main()
{
	CMy my;	// 객체 선언
	CMy my2;
	my.m_i2 = 3; // public으로 선언된 것만 접근 가능


	my.SetInt(15); // m_i1에는 원래 직접 접근 불가능하지만 함수로는 접근가능
	// CMy::SetInt(20); 반드시 객체가 필요함

	my2 = my; 
	// 원래 컴파일러는 우리가 만드는 클래스(자료형)에 대한 =연산자 사용을 만들어 놓지 않았다.
	// 하지만 컴파일러 내부에서 클래스를 만들때 우리가 만든 클래스에 대한 대입연산자(=)를 생성자 소멸자처럼 만들어줘서 사용 가능한것


	// 레퍼런스 변수
	int a = 10;
	int b = 20;

	int* p = &a;
	*p = 100;		// a변수에 100 대입

	int& iRef = a;
	iRef = 200;		// a변수에 200 대입
	// 어셈블리 내에서 포인터와 똑같다
	// a의 주소를 받아와서 a내의 값 변경
	// 참조 대상을 변경 불가능
	iRef = b;	// 오류가 생기지는 않음 ==> 왜냐 이 코드는 b를 참조하겠다는게 아니라 b의 값을 a에 넣겠다는 뜻임
				// 따라서 b를 초기화 하지 않았을때 오류가 걸림
				// 따라서 a에는 b의 20이 들어간다

	
	// 그럼 왜쓸까요??????
	int* const piConst = &a;
	// 이렇게 쓰는거보다 일단 훨 편하고
	// 개발자 입장에서 주소랑 관련이 없어보이기 때문에 실수 가능성 적음
	// (애초에 주소관련해서 수정할 코드가 없어짐 - 안전)
	// **그리고 결정적인 장점이 있는데**
	// 포인터는 사용하려면 매번 역참조 연산을 해야하는데
	// 레퍼런스는 참조변수를 통해서 직접적으로 원본 수정 가능
	
	// 참조하는데 원본 수정 못하게 하려면
	const int& iRefConst = a;
	// 요로코롬 하면 iRefConst를 통해서 a 수정 불가능
	// 그리고 원래 레퍼런스가 포인터 const와 같기 때문에
	// 이렇게 선언해버리면 iRefConst를 통해서 주소, 주소내부 둘 다 수정 불가

	CMy c1, c2, c3;

	c1 = c2 = c3;




	// 내가만든 가변배열 클래스
	CArr<int> arr1;

	srand((unsigned int)time(NULL));
	rand();

	for (int i = 0; i < 10; ++i)
		arr1.PushBack(rand() % 100+1);

	for (int i = 0; i < 10; ++i)
		cout << arr1[i] << endl;

	arr1.BubbleSort();
	
	cout << endl;

	for (int i = 0; i < 10; ++i)
		cout << arr1[i] << endl;
	

	// 리턴으로 종료시킬때 스택이 종료되기전 클래스 선언한 순서대로
	// 소멸자를 호출해준다
	return 0;
}